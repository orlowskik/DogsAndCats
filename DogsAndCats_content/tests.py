from django.db import IntegrityError, DataError
from django.test import TestCase
from django.core.exceptions import ValidationError

from .models import User, Pet

import pytest

testmail = 'test@example.com'


# Create your tests here.
# Generated by CodiumAI
class TestUserModel(TestCase):

    #  Creating a new user with valid username, password, and email should succeed.
    def test_create_user_with_valid_credentials(self):
        user = User(username="testuser", password="password123", email="testuser@example.com")
        assert user.username == "testuser"
        assert user.password == "password123"
        assert user.email == "testuser@example.com"

    #  Retrieving an existing user by their username or email should succeed.
    def test_retrieve_existing_user(self):
        user = User.objects.create(username="testuser", password="password123", email="testuser@example.com")
        retrieved_user = User.objects.get(username="testuser")
        assert retrieved_user == user
        retrieved_user = User.objects.get(email="testuser@example.com")
        assert retrieved_user == user

    #  Updating an existing user's username, password, or email should succeed.
    def test_update_existing_user(self):
        user = User.objects.create(username="testuser", password="password123", email="testuser@example.com")
        user.username = "newusername"
        user.password = "newpassword123"
        user.email = "newemail@example.com"
        user.save()
        updated_user = User.objects.get(username="newusername")
        assert updated_user == user
        updated_user = User.objects.get(email="newemail@example.com")
        assert updated_user == user

    #  Creating a new user with an already existing username or email should fail.
    def test_create_user_with_existing_username(self):
        User.objects.create(username="testuser", password="password123", email="testuser@example.com")
        with pytest.raises(IntegrityError):
            User.objects.create(username="testuser", password="newpassword123", email="newemail@example.com")

    #  Creating a new user with an already existing username or email should fail.
    def test_create_user_with_existing_email(self):
        User.objects.create(username="testuser", password="password123", email="testuser@example.com")
        with pytest.raises(IntegrityError):
            User.objects.create(username="newusername", password="newpassword123", email="testuser@example.com")

    #  Creating a new user with an empty username, password, or email should fail.
    def test_create_user_with_empty_username(self):
        with pytest.raises(IntegrityError):
            User.objects.create(username="", password="password123", email="testuser@example.com")

    #  Creating a new user with an empty password should fail.
    def test_create_user_with_empty_password(self):
        with pytest.raises(IntegrityError):
            User.objects.create(username="testuser", password="", email="testuser@example.com")

    #  Creating a new user with an empty email should fail.
    def test_create_user_with_empty_email(self):
        with pytest.raises(IntegrityError):
            User.objects.create(username="testuser", password="password123", email="")

    #  Creating a new user with a password length less than 9 should fail.
    def test_create_user_with_short_password(self):
        with pytest.raises(ValidationError):
            user = User(username="testuser", password="pas", email="testuser@example.com")
            user.full_clean()

    #  Creating a new user with an invalid email format should fail.
    def test_invalid_email_format(self):
        with pytest.raises(ValidationError):
            user = User(username="testuser", password="password", email="invalid_email")
            user.full_clean()

    #  Updating an existing user's username to an already existing one should fail.
    def test_existing_username(self):
        # Create a user with a unique username and email
        user1 = User.objects.create(username="user1", password="password1", email="user1@example.com")

        user2 = User.objects.create(username="user2", password="password2", email="user2@example.com")

        # Attempt to update user1's username to an already existing username
        with pytest.raises(IntegrityError):
            user1.username = "user2"
            user1.save()

    #  Updating an existing user's email to an already existing one should fail.
    def test_existing_email(self):
        # Create a user with a unique username and email
        user1 = User.objects.create(username="user1", password="password1", email="user1@example.com")

        user2 = User.objects.create(username="user2", password="password2", email="user2@example.com")

        # Attempt to update user1's email to an already existing email
        with pytest.raises(IntegrityError):
            user1.email = "user2@example.com"
            user1.save()

    #  Updating an existing user's password to a length less than 9 should fail.
    def test_update_password_length_less_than_8_should_fail(self):
        # Create a user with a password length of 8
        user = User.objects.create(username="test_user", password="password123", email="test@example.com")

        # Update the user's password to a length less than 8
        user.password = "pass"

        # Attempt to save the user
        with pytest.raises(IntegrityError):
            user.save()

    #  Deleting an existing user should succeed.
    def test_deleting_existing_user(self):
        # Create a user
        user = User.objects.create(username="test_user", password="password123", email="test@example.com")

        # Delete the user
        user.delete()

        # Check if the user is deleted
        assert not User.objects.filter(username="test_user").exists()

    #  Attempting to create a new user with an email that exceeds the maximum length should fail.
    def test_email_length_exceeds_maximum(self):
        with pytest.raises(DataError):
            user = User(username="test", password="password", email='a' * 100 + '@example.com')
            user.save()

    #  Attempting to create a new user with a username that exceeds the maximum length should fail.
    def test_username_length_exceeds_maximum(self):
        with pytest.raises(DataError):
            user = User(username="a" * 41, password="password", email=testmail)
            user.save()

    #  Attempting to create a new user with a password that exceeds the maximum length should fail.
    def test_password_exceeds_max_length(self):
        with pytest.raises(DataError):
            user = User(username="test_user", password="01234567890123456", email="test@example.com")
            user.save()

    #  Attempting to create a new user with an email that contains invalid characters should fail.
    def test_email_invalid_characters(self):
        # Test email with invalid characters
        with pytest.raises(ValidationError):
            user = User(username="username", password="password123", email="user@exa@mple.com")
            user.full_clean()

    #  Attempting to create a new user with an email that contains invalid characters should fail.
    def test_password_invalid_characters(self):
        # Test password with invalid characters
        with pytest.raises(ValidationError):
            user = User(username="username", password="pass word", email="user@example.com")
            user.full_clean()

    # Attempting to update an existing user's username, password, or email to a value that exceeds the maximum length
    # should fail.
    def test_update_user_exceed_max_length(self):
        # Create a user with a valid username, password, and email
        user = User(username="testuser", password="password123", email="testuser@example.com")
        user.save()

        # Attempt to update the username to a value that exceeds the maximum length
        user.username = "a" * 41
        with pytest.raises(DataError):
            user.save()

    def test_update_password_exceed_max_length(self):
        # Create a user with a valid username, password, and email
        user = User(username="testuser", password="password123", email="testuser@example.com")
        user.save()
        # Attempt to update the password to a value that exceeds the maximum length
        user.password = "a" * 41
        with pytest.raises(DataError):
            user.save()

    def test_update_email_exceed_max_length(self):
        # Create a user with a valid username, password, and email
        user = User(username="testuser", password="password123", email="testuser@example.com")
        user.save()
        # Attempt to update the email to a value that exceeds the maximum length
        user.email = "a" * 101
        with pytest.raises(DataError):
            user.save()

    #  Retrieving a non-existent user should fail.
    def test_retrieving_nonexistent_user_should_fail(self):
        with pytest.raises(User.DoesNotExist):
            User.objects.get(username="nonexistent_user")


# Generated by CodiumAI
class TestPet(TestCase):

    #  Creating a new Pet instance with valid parameters should be successful.
    def test_create_pet_with_valid_parameters(self):
        user = User.objects.create(username="test_user", password="test_password", email="test@test.com")
        pet = Pet.objects.create(name="test_pet", kind="Dog", breed="Labrador", age=2, color="Brown",
                                 description="Friendly dog", owner=user)
        assert pet.name == "test_pet"
        assert pet.kind == "Dog"
        assert pet.breed == "Labrador"
        assert pet.age == 2
        assert pet.color == "Brown"
        assert pet.description == "Friendly dog"
        assert pet.owner == user

    #  Retrieving an existing Pet instance should return the correct object.
    def test_retrieve_existing_pet_instance(self):
        user = User.objects.create(username="test_user", password="test_password", email="test@test.com")
        pet = Pet.objects.create(name="test_pet", kind="Dog", breed="Labrador", age=2, color="Brown",
                                 description="Friendly dog", owner=user)
        retrieved_pet = Pet.objects.get(name="test_pet")
        assert retrieved_pet == pet

    #  Updating a Pet instance with valid parameters should be successful.
    def test_update_pet_with_valid_parameters(self):
        user = User.objects.create(username="test_user", password="test_password", email="test@test.com")
        pet = Pet.objects.create(name="test_pet", kind="Dog", breed="Labrador", age=2, color="Brown",
                                 description="Friendly dog", owner=user)
        pet.name = "updated_pet"
        pet.save()
        assert pet.name == "updated_pet"

    #  Creating a new Pet instance with an empty name should raise a validation error.
    def test_create_pet_with_empty_name(self):
        user = User.objects.create(username="test_user", password="test_password", email="test@test.com")
        with pytest.raises(Exception):
            Pet.objects.create(name="", kind="Dog", breed="Labrador", age=2, color="Brown", description="Friendly dog",
                               owner=user)

    #  Creating a new Pet instance with an invalid kind should raise a validation error.
    def test_create_pet_with_invalid_kind(self):
        user = User.objects.create(username="test_user", password="test_password", email="test@test.com")
        with pytest.raises(Exception):
            Pet.objects.create(name="test_pet", kind="Cat", breed="Labrador", age=2, color="Brown",
                               description="Friendly dog", owner=user)

    #  Creating a new Pet instance with a negative age should raise a validation error.
    def test_create_pet_with_negative_age(self):
        user = User.objects.create(username="test_user", password="test_password", email="test@test.com")
        with pytest.raises(DataError):
            Pet.objects.create(name="test_pet", kind="Dog", breed="Labrador", age=-2, color="Brown",
                               description="Friendly dog", owner=user)

    #  Deleting a Pet instance should remove it from the database.
    def test_delete_pet_instance(self):
        # Create a user
        user = User.objects.create(username="test_user", password="password123", email="test@example.com")

        # Create a pet
        pet = Pet.objects.create(name="Fluffy", kind="Cat", breed="Persian", age=3, color="White",
                                 description="Cute cat", owner=user)

        # Delete the pet
        pet.delete()

        # Check if the pet is removed from the database
        assert not Pet.objects.filter(name="Fluffy").exists()

    #  Creating a new Pet instance with a too long breed should raise a validation error.
    def test_create_pet_with_long_breed(self):
        user = User.objects.create(username="testuser", password="testpassword", email="test@example.com")
        with pytest.raises(ValidationError):
            Pet.objects.create(name="Fluffy", breed="a" * 41, age=2, color="white", description="Cute pet", owner=user)

    #  Creating a new Pet instance with a too long color should raise a validation error.
    def test_create_pet_with_long_color(self):
        user = User.objects.create(username="testuser", password="testpassword", email="test@example.com")
        with pytest.raises(ValidationError):
            pet = Pet.objects.create(name="Fluffy", kind="Dog", breed="Labrador", age=2,
                                     color="This is a very long color that exceeds the maximum length allowed",
                                     description="A cute dog", owner=user)

    #  Creating a new Pet instance with a too long description should raise a validation error.
    def test_description_too_long(self):
        pet = Pet(name="Max",
                  description="Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed ac nunc nec nisl aliquam "
                              "lacinia. Nulla facilisi. Sed id semper nunc. Sed euismod, nisl nec tincidunt ultrices, "
                              "nunc ligula aliquet justo, id lacinia tellus mi in lectus. Sed euismod, "
                              "nisl nec tincidunt ultrices, nunc ligula aliquet justo, id lacinia tellus mi in "
                              "lectus.")
        with pytest.raises(ValidationError):
            pet.full_clean()

    #  Creating a new Pet instance with a non-existing owner should raise an integrity error.
    def test_create_pet_with_non_existing_owner(self):
        with pytest.raises(IntegrityError):
            Pet.objects.create(name="test_pet", kind="Dog", breed="Labrador", age=2, color="Brown",
                               description="Friendly dog", owner_id=999)

    #  Retrieving a non-existing Pet instance should raise a DoesNotExist exception.
    def test_retrieving_non_existing_pet(self):
        with pytest.raises(Pet.DoesNotExist):
            Pet.objects.get(id=1)

    #  Updating a Pet instance with invalid parameters should raise a validation error.
    def test_invalid_parameters_name(self):
        user = User.objects.create(username="testuser", password="password", email="testuser@example.com")
        pet = Pet.objects.create(name="Fluffy", kind="Dog", breed="Labrador", age=3, color="Brown",
                                 description="Friendly dog", owner=user)

        # Test updating name with an empty string
        with pytest.raises(ValidationError):
            pet.name = ""
            pet.full_clean()

    #  Updating a Pet instance with invalid parameters should raise a validation error.
    def test_invalid_parameters_breed(self):
        user = User.objects.create(username="testuser", password="password", email="testuser@example.com")
        pet = Pet.objects.create(name="Fluffy", kind="Dog", breed="Labrador", age=3, color="Brown",
                                 description="Friendly dog", owner=user)
        # Test updating breed with a string longer than 40 characters
        with pytest.raises(ValidationError):
            pet.breed = "This is a very long breed name that exceeds the maximum length allowed"
            pet.full_clean()

    #  Updating a Pet instance with invalid parameters should raise a validation error.
    def test_invalid_parameters_age(self):
        user = User.objects.create(username="testuser", password="password", email="testuser@example.com")
        pet = Pet.objects.create(name="Fluffy", kind="Dog", breed="Labrador", age=3, color="Brown",
                                 description="Friendly dog", owner=user)
        # Test updating age with a negative value
        with pytest.raises(ValidationError):
            pet.age = -1
            pet.full_clean()

    #  Updating a Pet instance with invalid parameters should raise a validation error.
    def test_invalid_parameters_color(self):
        user = User.objects.create(username="testuser", password="password", email="testuser@example.com")
        pet = Pet.objects.create(name="Fluffy", kind="Dog", breed="Labrador", age=3, color="Brown",
                                 description="Friendly dog", owner=user)

        # Test updating color with a string longer than 40 characters
        with pytest.raises(ValidationError):
            pet.color = "This is a very long color name that exceeds the maximum length allowed"
            pet.full_clean()

    #  Updating a Pet instance with invalid parameters should raise a validation error.
    def test_invalid_parameters_desc(self):
        user = User.objects.create(username="testuser", password="password", email="testuser@example.com")
        pet = Pet.objects.create(name="Fluffy", kind="Dog", breed="Labrador", age=3, color="Brown",
                                 description="Friendly dog", owner=user)

        # Test updating description with a string longer than 200 characters
        with pytest.raises(ValidationError):
            pet.description = 'a'*201
            pet.full_clean()

    #  Deleting a non-existing Pet instance should raise a DoesNotExist exception.
    def test_delete_non_existing_pet(self):
        with pytest.raises(Pet.DoesNotExist):
            Pet.objects.get(id=100)

    #  Retrieving all Pet instances should return a QuerySet containing all objects.
    def test_retrieve_all_pet_instances(self):
        # Create some Pet instances
        pet1 = Pet.objects.create(name="Fluffy", kind="Cat", breed="Persian", age=3, color="White",
                                  description="Cute and fluffy",
                                  owner=User.objects.create(username="user1", password="password1",
                                                            email="user1@example.com"))
        pet2 = Pet.objects.create(name="Buddy", kind="Dog", breed="Labrador", age=5, color="Golden",
                                  description="Friendly and playful",
                                  owner=User.objects.create(username="user2", password="password2",
                                                            email="user2@example.com"))
        pet3 = Pet.objects.create(name="Max", kind="Dog", breed="German Shepherd", age=2, color="Black and Tan",
                                  description="Loyal and protective",
                                  owner=User.objects.create(username="user3", password="password3",
                                                            email="user3@example.com"))

        # Retrieve all Pet instances
        pets = Pet.objects.all()

        # Check if the QuerySet contains all objects
        assert len(pets) == 3
        assert pet1 in pets
        assert pet2 in pets
        assert pet3 in pets

    #  Filtering Pet instances by owner should return a QuerySet containing only objects with the specified owner.
    def test_filter_pet_by_owner(self):
        # Create a user
        user = User.objects.create(username="test_user", password="test_password", email="test@test.com")

        # Create pets with different owners
        pet1 = Pet.objects.create(name="pet1", kind="Dog", breed="breed1", age=1, color="color1",
                                  description="description1", owner=user)
        pet2 = Pet.objects.create(name="pet2", kind="Dog", breed="breed2", age=2, color="color2",
                                  description="description2", owner=user)
        pet3 = Pet.objects.create(name="pet3", kind="Dog", breed="breed3", age=3, color="color3",
                                  description="description3", owner=user)

        # Create a pet with a different owner
        other_user = User.objects.create(username="other_user", password="other_password", email="other@test.com")
        pet4 = Pet.objects.create(name="pet4", kind="Dog", breed="breed4", age=4, color="color4",
                                  description="description4", owner=other_user)

        # Filter pets by owner
        filtered_pets = Pet.objects.filter(owner=user)

        # Check that only pets with the specified owner are returned
        assert pet1 in filtered_pets
        assert pet2 in filtered_pets
        assert pet3 in filtered_pets
        assert pet4 not in filtered_pets
